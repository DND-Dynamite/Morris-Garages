<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conceptual FEM App</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-4">

    <!-- Main Container -->
    <div class="container mx-auto p-8 bg-gray-800 rounded-2xl shadow-lg max-w-5xl w-full flex flex-col gap-6">

        <!-- Header -->
        <header class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-teal-400 mb-2">Conceptual FEM Simulator</h1>
            <p class="text-gray-400 text-sm md:text-base">Upload a .STL model, apply forces, and visualize a simulated stress analysis.</p>
        </header>

        <!-- Main Content Area -->
        <div class="flex flex-col md:flex-row gap-6 h-full min-h-[600px]">

            <!-- 3D Viewport & Legend -->
            <div id="viewport-container" class="relative w-full md:w-2/3 h-[500px] bg-gray-900 rounded-xl overflow-hidden shadow-inner border border-gray-700">
                <canvas id="femCanvas" class="w-full h-full"></canvas>

                <!-- Legend -->
                <div id="legend" class="absolute bottom-4 left-4 bg-gray-800 p-3 rounded-lg shadow-md hidden">
                    <h3 class="text-sm font-semibold mb-2 text-gray-300">Stress Simulation</h3>
                    <div class="flex flex-col gap-1">
                        <div class="flex items-center">
                            <div class="w-4 h-4 rounded-full bg-red-500 mr-2"></div>
                            <span class="text-xs text-gray-400">High Stress</span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-4 h-4 rounded-full bg-blue-500 mr-2"></div>
                            <span class="text-xs text-gray-400">Low Stress</span>
                        </div>
                    </div>
                </div>

                <!-- Placeholder for model -->
                <div id="placeholder" class="absolute inset-0 flex flex-col items-center justify-center p-4 text-center">
                    <svg class="w-16 h-16 text-gray-600 mb-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 5-4V15z" clip-rule="evenodd"></path>
                    </svg>
                    <p class="text-gray-500">Upload a .STL file to begin.</p>
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="w-full md:w-1/3 p-6 bg-gray-700 rounded-xl shadow-md flex flex-col gap-4">

                <!-- File Upload -->
                <div>
                    <label for="stl-file-input" class="block text-sm font-medium text-gray-300 mb-2">Upload .STL Model</label>
                    <input type="file" id="stl-file-input" accept=".stl" class="block w-full text-sm text-gray-400
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-teal-50 file:text-teal-700
                        hover:file:bg-teal-100 cursor-pointer">
                </div>

                <!-- Instructions for applying forces -->
                <div id="instruction-panel" class="hidden">
                    <p class="text-gray-400 text-sm italic">
                        Click on the 3D model to apply a force.
                    </p>
                    <button id="clear-forces-btn" class="mt-2 w-full px-4 py-2 text-sm font-semibold text-white bg-red-500 rounded-full hover:bg-red-600 transition-colors">
                        Clear Forces
                    </button>
                </div>

                <!-- Run Simulation Button -->
                <button id="run-simulation-btn" class="w-full px-6 py-3 text-lg font-semibold text-white bg-teal-500 rounded-full shadow-lg hover:bg-teal-600 focus:outline-none focus:ring-2 focus:ring-teal-400 focus:ring-offset-2 focus:ring-offset-gray-700 transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed">
                    Run Simulation
                </button>

                <!-- Status & Results -->
                <div id="status-message" class="text-center text-sm font-medium text-gray-400 hidden">
                    <span id="status-text"></span>
                    <div id="loading-spinner" class="mt-2 hidden animate-spin rounded-full h-8 w-8 border-4 border-t-4 border-teal-500 border-gray-600 mx-auto"></div>
                </div>

                <p class="text-gray-500 text-xs mt-auto">
                    This is a conceptual demonstration and does not perform real-world FEM. The stress visualization is simulated.
                </p>
            </div>

        </div>
    </div>

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        (function() {
            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('femCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Get DOM elements
            const fileInput = document.getElementById('stl-file-input');
            const runBtn = document.getElementById('run-simulation-btn');
            const clearForcesBtn = document.getElementById('clear-forces-btn');
            const statusMessage = document.getElementById('status-message');
            const statusText = document.getElementById('status-text');
            const loadingSpinner = document.getElementById('loading-spinner');
            const legend = document.getElementById('legend');
            const placeholder = document.getElementById('placeholder');
            const viewportContainer = document.getElementById('viewport-container');
            const instructionPanel = document.getElementById('instruction-panel');

            // Set up camera and controls
            camera.position.z = 5;
            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.75);
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            // State variables
            let currentModel = null;
            let forcePoints = [];
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            // Render loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }

            // Handle file upload
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // Reset UI and state
                clearForces();
                statusMessage.classList.add('hidden');
                runBtn.disabled = false;
                runBtn.textContent = 'Run Simulation';
                legend.classList.add('hidden');
                placeholder.classList.add('hidden');
                instructionPanel.classList.remove('hidden');

                if (currentModel) {
                    scene.remove(currentModel);
                    currentModel.geometry.dispose();
                    if (currentModel.material.length) {
                        currentModel.material.forEach(m => m.dispose());
                    } else {
                        currentModel.material.dispose();
                    }
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(contents);

                    // Center and scale the geometry
                    geometry.computeBoundingBox();
                    const boundingBox = geometry.boundingBox;
                    const size = new THREE.Vector3();
                    boundingBox.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = 3 / maxDim;
                    geometry.scale(scaleFactor, scaleFactor, scaleFactor);
                    geometry.center();

                    const material = new THREE.MeshPhongMaterial({ color: 0xcccccc, specular: 0x111111, shininess: 200 });
                    currentModel = new THREE.Mesh(geometry, material);
                    scene.add(currentModel);

                    // Reposition camera
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    controls.target.copy(center);
                    controls.update();
                };
                reader.readAsArrayBuffer(file);
            });

            // Handle mouse clicks for applying forces
            function onMouseClick(event) {
                if (!currentModel) return;

                // Calculate mouse position in normalized device coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObject(currentModel);
                if (intersects.length > 0) {
                    const intersectionPoint = intersects[0].point;

                    // Create a visual representation of the force
                    const forceGeometry = new THREE.SphereGeometry(0.05, 16, 16);
                    const forceMaterial = new THREE.MeshBasicMaterial({ color: 0xff4136 });
                    const forceSphere = new THREE.Mesh(forceGeometry, forceMaterial);
                    forceSphere.position.copy(intersectionPoint);
                    scene.add(forceSphere);
                    forcePoints.push(forceSphere);

                    // Reset to default material if it was colored
                    if (currentModel.material instanceof THREE.MeshBasicMaterial) {
                        const defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc, specular: 0x111111, shininess: 200 });
                        currentModel.material = defaultMaterial;
                        currentModel.geometry.deleteAttribute('color');
                    }
                    legend.classList.add('hidden');
                }
            }
            window.addEventListener('click', onMouseClick, false);

            // "FEM" Simulation logic
            runBtn.addEventListener('click', () => {
                if (!currentModel || forcePoints.length === 0) {
                    statusText.textContent = 'Please upload a model and apply at least one force.';
                    statusMessage.classList.remove('hidden');
                    return;
                }

                runBtn.disabled = true;
                runBtn.innerHTML = 'Simulating...';
                statusMessage.classList.remove('hidden');
                statusText.textContent = 'Running FEM...';
                loadingSpinner.classList.remove('hidden');

                // Simulate a delay for the "computation"
                setTimeout(() => {
                    const positionAttribute = currentModel.geometry.getAttribute('position');
                    const colorAttribute = new THREE.Float32BufferAttribute(positionAttribute.count * 3, 3);
                    
                    const stressVectors = forcePoints.map(p => p.position);
                    
                    const tempVector = new THREE.Vector3();
                    for (let i = 0; i < positionAttribute.count; i++) {
                        tempVector.fromBufferAttribute(positionAttribute, i);
                        
                        let minDistance = Infinity;
                        for (const forceVector of stressVectors) {
                            const distance = tempVector.distanceTo(forceVector);
                            if (distance < minDistance) {
                                minDistance = distance;
                            }
                        }
                        
                        // Invert the distance to get a "stress" value (closer = higher stress)
                        // A small constant is added to avoid division by zero
                        const simulatedStress = 1 / (minDistance + 0.1); 
                        
                        // Normalize the stress value (clamping and scaling for visual effect)
                        const normalizedStress = Math.min(simulatedStress / 2, 1);
                        
                        // Create a color from blue (low) to red (high)
                        const color = new THREE.Color();
                        color.setRGB(normalizedStress, 0, 1 - normalizedStress); 
                        
                        colorAttribute.setXYZ(i, color.r, color.g, color.b);
                    }

                    // Replace the existing geometry with a new one that has vertex colors
                    const newGeometry = currentModel.geometry.clone();
                    newGeometry.setAttribute('color', colorAttribute);
                    const newMaterial = new THREE.MeshBasicMaterial({ vertexColors: true });
                    
                    // Cleanup old geometry and materials
                    scene.remove(currentModel);
                    currentModel.geometry.dispose();
                    
                    currentModel = new THREE.Mesh(newGeometry, newMaterial);
                    scene.add(currentModel);

                    // Show results
                    runBtn.innerHTML = 'Run Simulation Again';
                    runBtn.disabled = false;
                    statusText.textContent = 'Simulation complete!';
                    loadingSpinner.classList.add('hidden');
                    legend.classList.remove('hidden');
                }, 2000); // 2-second delay
            });

            // Clear Forces button handler
            clearForcesBtn.addEventListener('click', clearForces);
            function clearForces() {
                forcePoints.forEach(sphere => scene.remove(sphere));
                forcePoints = [];
            }

            // Handle window resizing
            function onWindowResize() {
                const newWidth = viewportContainer.clientWidth;
                const newHeight = viewportContainer.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            }
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Call initially to set the size

            // Start the animation loop
            animate();
        })();
    </script>
</body>
</html>
